version: 1.3
type: update
build: 201807232048
id: letsencrypt-ssl-addon
name: Let's Encrypt Free SSL

categories:
- apps/dev-and-admin-tools

targetNodes:
  nodeType:
    - tomcat6
    - tomcat7
    - tomcat8
    - tomcat85
    - tomcat9
    - tomcat
    - tomee
    - tomee-dockerized
    - glassfish3
    - glassfish4
    - glassfish
    - jetty
    - jetty6
    - apache
    - apache2
    - nginxphp
    - apache2-ruby
    - nginx-ruby
    - nginx
    - nginx-dockerized
    - nginxphp-dockerized
    - haproxy
    - apache-lb
    - varnish
    - varnish-dockerized
    - payara
    - wildfly
    - nodejs
    - apache-ruby
    - apache-python
    - nginxruby
    - litespeedphp
    - litespeedadc
    - lemp
    - llsmp
    - jenkins
    - jenkins2

homepage: https://github.com/jelastic-jps/lets-encrypt
baseUrl: https://raw.githubusercontent.com/lazarenkoalexey/lets-encrypt/skipped
logo: images/letsencrypt.png

description:
  text: /text/description.md
  short: Free tool to configure support of secured SSL connection for an environment,
    by either internal or custom domain name.

globals:
  scriptSufix: letsencrypt-ssl

mixins:
  - configs/vers.yaml

settings:
  fields:
    - type: string
      name: customDomains
      vtype: domainlist
      caption: External Domain(s)
      placeholder: leave blank to get a test certificate for this environment domain
      required: false
      tooltip: |
        Each of the specified external domains should be preliminarily bound via DNS record to the external IP of the node where add-on is installed (either directly via <a href="https://docs.jelastic.com/custom-domains/#how-to-configure-dns-record" target="_blank">A Record</a> or through CDN / external balancer proxy).<br><br>
        <b>Note:</b> Leave this field blank for issuing a test SSL certificate bound to the internal environment domain.

onBeforeRedeployContainer [${targetNodes.nodeGroup}]:
  callScript:
    action: backup-scripts

onAfterRedeployContainer [${targetNodes.nodeGroup}]:
  callScript:
    action: restore-scripts

onAfterStart:
  callScript:
    action: check-for-update

buttons:
  - confirmText: Do you want to update attached SSL certificate(s)?
    loadingText: Updating...
    action: update
    caption: Update Now
    successText: /text/success.md
  - caption: Configure
    settings: main
    action: configure

onInstall:
  - setGlobals:
      nodeId: ${settings.nodeId:}
      nodeGroup: ${targetNodes.nodeGroup:}
      withExtIp: ${settings.withExtIp:true}
      webroot: ${settings.webroot:}
      webrootPath: ${settings.webrootPath:}
      fallbackToX1: ${settings.fallbackToX1:}
      deployHook: ${settings.deployHook:}
      deployHookType: ${settings.deployHookType:}
      undeployHook: ${settings.undeployHook:}
      undeployHookType: ${settings.undeployHookType:}
      test: ${settings.test:}
  - installScript
  - checkClustering:
      app_id: letsencrypt-ssl-addon

onUninstall:
  - callScript:
      action: uninstall
  - delete
  - checkClustering:
      app_id: letsencrypt-ssl-addon
      action: configure


onBeforeDelete: delete

onAfterClone:
  install: ${baseUrl}/manifest.jps?_r=${fn.random}
  envName: ${event.response.env.envName}
  nodeGroup: ${globals.nodeGroup}
  settings:
    customDomains: ''
    nodeGroup: ${globals.nodeGroup}
    deployHookType: ${globals.deployHookType}
    undeployHookType: ${globals.undeployHookType}
    withExtIp: ${globals.withExtIp}
    webroot: ${globals.webroot}
    webrootPath: ${globals.webrootPath}
    fallbackToX1: ${globals.fallbackToX1}
    test: ${globals.test}

onAfterConfirmTransfer: installScript

actions:
  installScript:
    script: /scripts/create-installation-script.js?_r=${fn.random}
    params:
      scriptName: ${env.envName}-${targetNodes.nodeGroup}-${globals.scriptSufix}
      baseUrl: ${baseUrl}
      cronTime: 0 ${fn.random(1,6)},${fn.random(10,14)},${fn.random(15,20)} * * *
      customDomains: ${settings.customDomains}
      nodeId: ${globals.nodeId}
      nodeGroup: ${globals.nodeGroup}
      deployHook: ${globals.deployHook}
      deployHookType: ${globals.deployHookType}
      undeployHook: ${globals.undeployHook}
      undeployHookType: ${globals.undeployHookType}
      withExtIp: ${globals.withExtIp}
      webroot: ${globals.webroot}
      webrootPath: ${globals.webrootPath}
      fallbackToX1: ${globals.fallbackToX1}
      test: ${globals.test}
      clientVersion: ${globals.version_acme-sh:}

  callScript:
    script: |
      var j = jelastic, resp = j.dev.scripting.Eval(appid, session, '${env.envName}-${targetNodes.nodeGroup}-${globals.scriptSufix}', {action:'${this.action}'});
      if (resp.result == 0 && typeof resp.response === 'object' && resp.response.result != 0) resp = resp.response;
      return resp;

  update:
    - callScript:
        action: auto-update
    - checkClustering:
        app_id: letsencrypt-ssl-addon
        action: configure

  configure:
    - installScript
    - checkClustering:
        app_id: letsencrypt-ssl-addon
        action: configure

  delete:
    script: |
      jelastic.dev.scripting.DeleteScript('${env.envName}-${targetNodes.nodeGroup}-${globals.scriptSufix}');
      return {result:0}

  checkClustering:
    script: |
      var UPDATE = "update",
        KEYS = "/var/lib/jelastic/keys/",
        action = "${this.action:}",
        secondEnvName,
        config = {},
        isLockEnv,
        envApid,
        resp,
        obj;

      resp = api.env.control.ExecCmdByGroup({
        envName: "${env.name}",
        session: session,
        nodeGroup: "cp",
        commandList: [{"command": "cat " + KEYS + "clustering"}]
      });
      if (resp.result != 0) return resp;

      text = resp.responses[0].out.split("\n");

      for (var i = 0, n = text.length; i < n; i++) {
        tmp = text[i].split("=");
        config[tmp[0]] = tmp[1];
      }

      if (config.cluster) config.cluster = String(config.cluster) != "false";

      if (config.cluster) {
        secondEnvName = ("${env.name}" == config.envName1) ? config.envName2 : config.envName1;
        
        resp = api.env.control.ExecCmdByGroup({
          envName: "${env.name}",
          session: session,
          nodeGroup: "cp",
          commandList: [{"command": "[[ -f \"" + KEYS + "letsencrypt-ssl-addon.lock\" ]] && echo true || echo false"}]
        });
        if (resp.result != 0) return resp;
        
        isLockEnv = !!(resp.responses[0].out == "true");
        
        if (isLockEnv) {
          if (action) {
            return {
              result: 0,
              onAfterReturn: [
                {
                  executeAppAction: {
                    envName: secondEnvName,
                    action: action,
                    app_id: "${this.app_id}"
                  }
                }
              ]
            }
          }
          return {result: 0}
        }

        
        return {
          result: 0,
          onAfterReturn: [
            {
              createLockFile: {
                envName: secondEnvName,
                app_id: "${this.app_id}"
              }
            },
            {
              installSkippedAddon: {
                envName: secondEnvName,
                jps: "https://github.com/lazarenkoalexey/lets-encrypt/blob/skipped/manifest.jps"
              }
            }
          ]
        }
      }

      return {
        result: 0
      }

  createLockFile:
    script: |
      return api.env.control.ExecCmdByGroup({
        envName: "${this.envName}",
        session: session,
        nodeGroup: "cp",
        commandList: [{"command": "touch /var/lib/jelastic/keys/${this.app_id}.lock"}]
      });

  installSkippedAddon:
    script: |
      return api.marketplace.jps.Install({
        appid: appid,
        session: session,
        jps: "${this.jps}" || "https://github.com/jelastic-jps/lets-encrypt/blob/master/manifest.jps",
        envName: "${this.envName}",
        nodeGroup: "cp",
        settings: {
          customDomains: "${settings.customDomains}",
          nodeGroup: "${globals.nodeGroup}",
          deployHookType: "${globals.deployHookType}",
          undeployHookType: "${globals.undeployHookType}",
          withExtIp: "${globals.withExtIp}",
          webroot: "${globals.webroot}",
          webrootPath: "${globals.webrootPath}",
          fallbackToX1: "${globals.fallbackToX1}",
          test: "${globals.test}"
        }
      });
      
  executeAppAction:
    script: |
      var UPDATE ="update",
        uniqueName,
        envAppid,
        nodeType,
        resp;
        
      resp = api.env.control.GetEnvInfo("${this.envName}", session);
      if (resp.result != 0) return resp;
      
      for (var i = 0, n = resp.nodes.length; i < n; i++) {
        if (resp.nodes[i].nodeGroup == "${globals.nodeGroup}") {
          nodeType = resp.nodes[i].nodeType;
        }
      }
      
      envApid = resp.env.appid;
      
      resp = api.dev.scripting.Eval("appstore", session, "GetApps", {
        targetAppid: envApid,
        search: {
          appstore: 1,
          nodeGroup: "cp",
          nodeType: nodeType,
          jpsType: UPDATE
        }
      });
      if (resp.result != 0) return resp;
      
      if (resp.response && resp.response.apps) {
        for (var i = 0, n = resp.response.apps.length; i < n; i++) {
          if (resp.response.apps[i].app_id == "${this.app_id}") {
            uniqueName = resp.response.apps[i].uniqueName;
            break;
          }
        }
      }
      
      return api.marketplace.jps.ExecuteAppAction({
        appid: appid,
        session: session,
        appUniqueName: uniqueName,
        action: "${this.action}",
        params: {
          customDomains: "${settings.customDomains}",
          nodeGroup: "${globals.nodeGroup}",
          deployHookType: "${globals.deployHookType}",
          undeployHookType: "${globals.undeployHookType}",
          withExtIp: "${globals.withExtIp}",
          webroot: "${globals.webroot}",
          webrootPath: "${globals.webrootPath}",
          fallbackToX1: "${globals.fallbackToX1}",
          test: "${globals.test}"
        }
      });


success: /text/success.md
